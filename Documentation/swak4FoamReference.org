#+TITLE: The /incomplete/ =swak4Foam= reference
#+AUTHOR: Bernhard F.W. Gschaider

* Introduction
  This document gives an overview of the usage of =swak4Foam=. It
  explains the common paramters, expressions and usable parts. It is
  not intended as an introduction to =swak4Foam= (for that have a look
  at
  http://openfoamwiki.net/index.php/File:Swak4Foam_PSU2011_presentation.pdf).

  The structure of the document is
  - the first part gives an overview of the parsers. The parser is the
    part that reads expressions entered by the user and interprets
    them. These parsers are central to =swak4Foam= and this chapter
    explains
    - the expressions
    - common settings and concepts
    - order of evaluations
  - the next part describes the parts of =swak4foam= that are directly
    usable. This means
    - the utilities (including the popular =funkySetFields=)
    - boundary conditions (including =groovyBC=)
    - the collection of function objects
    - and the function plugins that can extend the parsers
  - the last part gives a short descrition on how to use functionality
    of =swak4foam= in your own programs
** Generating a printable version of this document
   This document was written in =org-mode= (http://orgmode.org) an
   outliner mode for the text editor Emacs. This mode offers a number
   of ways to export the contents to nicely formatted =HTML= and
   =PDF=. Please don't try to 'improve' the document in any other
   text-editor as all the indentations etc have special meaning.

   Some of the diagrams require external softaware packages (they are
   automatically called by =org-mode=):
   - Graphviz :: http://www.graphviz.org
   - Ditaa :: http://ditaa.sourceforge.net
   - PlantUML :: http://plantuml.sourceforge.net/
* The parsers (expression grammar)
  The central concept in =swak4Foam= is the /parser/. A parser reads a
  string with an expression, interprets it according to a grammar and
  then evaluates the grammar yielding a result.

  In principle each parser is composed of three elements pictured in
  figure \ref{fig:driverLexerParser}:
  - the =Lexer= which reads the tokens from the string (the lexers are
    generated by =flex= from a special description file)
  - the =GrammarParser= which gets the token from the =lexer= and
    interprets them according to a specified grammer (the grammar
    specification is turned into a program by =bison=)
  - the =Driver= is the part of the parser that is "seen" by the
    calling program. It
    - starts the grammar parser and the lexer
    - assists them in decisions like "is this symbol a variable?"
    - collects the results
    - implements concrete data generation actions (like reading
      fields, getting cell centers, etc)
  In the following texts the term /Parser/ will refer to this complex
  of three entities
  #+CAPTION: Relationship Driver/Lexer/Parser
  #+LABEL: fig:driverLexerParser
#+begin_src plantuml :file parserDriverLexer.png
Driver o-- Lexer
Driver o-- GrammarParser
Lexer .> GrammarParser
#+end_src

#+RESULTS:
[[file:parserDriverLexer.png]]

  Which parser is used depends on the entity the calculation is done
  on and determines the supported functionality (differential
  operators are for instance not available on =patch=). Figure
  \ref{fig:parserRelations} gives an overview of the available
  parser/driver and their relations. Parsers with a =<< grammar >>= in
  the name implement a parser/lexer pair which is used by the drivers
  derived from it. Drivers whose names are in /italics/ are only
  abstract classes.

  As all drivers are derived from /Common/ there is a set of options
  that is available in all drivers/parser.

  #+CAPTION: Inheritance relation of the Parsers
  #+LABEL: fig:parserRelations
#+begin_src plantuml :file parserRelationships.png
package swak4FoamParsers {
Common <|-- Field
Common <|-- Patch
Common <|-- Subset
Subset <|-- SetSubset
SetSubset <|-- CellSet
Subset <|-- CellZone
SetSubset <|-- FaceSet
Subset <|-- FaceZone
Subset <|-- SampledSet
Subset <|-- SampledSurface

class Field << grammar >>
class Patch << grammar >>
abstract class Subset << grammar >>
abstract class SetSubset
abstract class Common
}

package swakFiniteArea {
Common <|-- FaField
Common <|-- FaPatch

class FaField << grammar >>
class FaPatch << grammar >>
}

hide members
hide circle

#+end_src

#+RESULTS:
[[file:parserRelationships.png]]

  Usually the parser used is determined by the using entity (for
  instance =patch= is used by =groovyBC=) but sometimes (for instance
  the =swakExpression=-function object) the used parser can by
  selected by name. These names and a description of the entity the
  parser works on are given in table \ref{tab:selectionNames}.

  #+CAPTION: Selection names for the parsers
  #+LABEL: tab:selectionNames
  | name              | Description                                     |
  |-------------------+-------------------------------------------------|
  | =internalField=   | Calculation on the internal values of a field   |
  | =patch=           | Calculation on a boundary patch                 |
  | =faceZone=        | On a =faceZone= of the mesh                     |
  | =faceSet=         | On a =faceSet=                                  |
  | =cellZone=        | Calculation on a =cellZone=                     |
  | =cellSet=         | Set of cells                                    |
  | =set=             | Calculation on a =sampledSet=                   |
  | =surface=         | Calculation on a =sampledSurface=               |
  | =internalFaField= | Internal values of a FAM-field (=1.6-ext= only) |
  | =faPatch=         | Boundary patch of a FAM-field (=1.6-ext= only)  |

  In principle new parsers for different entities can be implemented
  and selected at run-time.

** Expressions
** Parameters
** Variables
* Usable parts
** Utilities
** Boundary conditions
** Function objects
** Function plugins
* Programming
