#+TITLE: The /incomplete/ =swak4Foam= reference
#+AUTHOR: Bernhard F.W. Gschaider

* Introduction
  This document gives an overview of the usage of =swak4Foam=. It
  explains the common paramters, expressions and usable parts. It is
  not intended as an introduction to =swak4Foam= (for that have a look
  at
  http://openfoamwiki.net/index.php/File:Swak4Foam_PSU2011_presentation.pdf).

  The structure of the document is
  - the first part gives an overview of the parsers. The parser is the
    part that reads expressions entered by the user and interprets
    them. These parsers are central to =swak4Foam= and this chapter
    explains
    - the expressions
    - common settings and concepts
    - order of evaluations
  - the next part describes the parts of =swak4foam= that are directly
    usable. This means
    - the utilities (including the popular =funkySetFields=)
    - boundary conditions (including =groovyBC=)
    - the collection of function objects
    - and the function plugins that can extend the parsers
  - the last part gives a short descrition on how to use functionality
    of =swak4foam= in your own programs
** Generating a printable version of this document
   This document was written in =org-mode= (http://orgmode.org) an
   outliner mode for the text editor Emacs. This mode offers a number
   of ways to export the contents to nicely formatted =HTML= and
   =PDF=. Please don't try to 'improve' the document in any other
   text-editor as all the indentations etc have special meaning.

   Some of the diagrams require external softaware packages (they are
   automatically called by =org-mode=):
   - Graphviz :: http://www.graphviz.org
   - Ditaa :: http://ditaa.sourceforge.net
   - PlantUML :: http://plantuml.sourceforge.net/
* The parsers (expression grammar)
  The central concept in =swak4Foam= is the /parser/. A parser reads a
  string with an expression, interprets it according to a grammar and
  then evaluates the grammar yielding a result.

  In principle each parser is composed of three elements pictured in
  figure \ref{fig:driverLexerParser}:
  - the =Lexer= which reads the tokens from the string (the lexers are
    generated by =flex= from a special description file)
  - the =GrammarParser= which gets the token from the =lexer= and
    interprets them according to a specified grammer (the grammar
    specification is turned into a program by =bison=)
  - the =Driver= is the part of the parser that is "seen" by the
    calling program. It
    - starts the grammar parser and the lexer
    - assists them in decisions like "is this symbol a variable?"
    - collects the results
    - implements concrete data generation actions (like reading
      fields, getting cell centers, etc)
  In the following texts the term /Parser/ will refer to this complex
  of three entities
  #+CAPTION: Relationship Driver/Lexer/Parser
  #+LABEL: fig:driverLexerParser
#+begin_src plantuml :file parserDriverLexer.png
Driver o-- Lexer
Driver o-- GrammarParser
Lexer .> GrammarParser
#+end_src

#+RESULTS:
[[file:parserDriverLexer.png]]

  Which parser is used depends on the entity the calculation is done
  on and determines the supported functionality (differential
  operators are for instance not available on =patch=). Figure
  \ref{fig:parserRelations} gives an overview of the available
  parser/driver and their relations. Parsers with a =<< grammar >>= in
  the name implement a parser/lexer pair which is used by the drivers
  derived from it. Drivers whose names are in /italics/ are only
  abstract classes.

  As all drivers are derived from /Common/ there is a set of options
  that is available in all drivers/parser.

  #+CAPTION: Inheritance relation of the Parsers
  #+LABEL: fig:parserRelations
#+begin_src plantuml :file parserRelationships.png
package swak4FoamParsers {
Common <|-- Field
Common <|-- Patch
Common <|-- Subset
Subset <|-- SetSubset
SetSubset <|-- CellSet
Subset <|-- CellZone
SetSubset <|-- FaceSet
Subset <|-- FaceZone
Subset <|-- SampledSet
Subset <|-- SampledSurface

class Field << grammar >>
class Patch << grammar >>
abstract class Subset << grammar >>
abstract class SetSubset
abstract class Common
}

package swakFiniteArea {
Common <|-- FaField
Common <|-- FaPatch

class FaField << grammar >>
class FaPatch << grammar >>
}

hide members
hide circle

#+end_src

#+RESULTS:
[[file:parserRelationships.png]]

  Usually the parser used is determined by the using entity (for
  instance =patch= is used by =groovyBC=) but sometimes (for instance
  the =swakExpression=-function object) the used parser can by
  selected by name. These names and a description of the entity the
  parser works on are given in table \ref{tab:selectionNames}.

  #+CAPTION: Selection names for the parsers
  #+LABEL: tab:selectionNames
  | name              | Description                                     |
  |-------------------+-------------------------------------------------|
  | =internalField=   | Calculation on the internal values of a field   |
  | =patch=           | Calculation on a boundary patch                 |
  | =faceZone=        | On a =faceZone= of the mesh                     |
  | =faceSet=         | On a =faceSet=                                  |
  | =cellZone=        | Calculation on a =cellZone=                     |
  | =cellSet=         | Set of cells                                    |
  | =set=             | Calculation on a =sampledSet=                   |
  | =surface=         | Calculation on a =sampledSurface=               |
  | =internalFaField= | Internal values of a FAM-field (=1.6-ext= only) |
  | =faPatch=         | Boundary patch of a FAM-field (=1.6-ext= only)  |

  In principle new parsers for different entities can be implemented
  and selected at run-time (as for instance are the /FAM/-parsers
  which are located in a separate library that has to be loaded at
  run-time)
** Expressions
   The basic syntax of the expressions is modelled after the syntax of
   expressions in OpenFOAM-programs. This means:
   - the syntax is C++
     - the usual precedence rules apply
   - if possible the same operators and function names as in OpenFOAM
     are used
   The type of result of an exprerssion does not have to be
   declared. swak4Foam determines it from the expression. In certain
   cases the calling entity (BC, functionObject etc) expects a certain
   type and will complain *after* the evaluation has finished.

   Available types are
   - scalar :: ordinary floating point expressions
   - vector :: a three component vector (usually describing a position
               in space)
   - tensor :: a tensor with $3 \times 3$ components
   - symmTensor :: a $3 \times 3$ symmetric tensor (for the components
                   $a_{ij}=a_{ji}$)
   - sphericalTensor :: Spherical tensor
   - boolean :: results of logical operations (can only be =true= or
                =false=). Certain parsers implement them with scalars
                being $0$ or $1$. If values other then $0$ or $1$ are
                found (which can happen for instance due to
                interpolation) they are interpreted as =true= (only
                exactly $0$ is interpreted as =false=)

   If the type of subexpressions for a certain operator/function is
   incompatible (for instance when trying to add a vector to a scalar)
   the parser will issue an error message during the evaluation.

   Most parsers have two kinds of structures where calculations are
   performed:
   1. the "native" structure of that parser. For instance for the
      =internalField=-parser this would be the values in the cells
   2. the "secondary" structure of the parser. For the =internalField=
      this would be the value on the faces (=internalField= is special
      as it also has another /secondary/ structure: the values on the
      vertexes)
   swak4Foam does *not* automatically convert values between these
   structures (as it usually involves an interpolation) but specific
   functions has to be used. The parser will complain if
   subexpressions of different structures are combined. This usually
   leads to confusion with constants which are defined on the /native/
   structure and have to be converted explicitly to the secondary
   structure if necessary (for instance =toPoint(1)= to use the
   constant =1= on the vertexes of a patch). Table
   \ref{tab:structures} gives an overview of the structures.

   #+CAPTION: Structures for the different parsers
   #+LABEL: tab:structures
   | Parser            | /native/ structure      | secondary structure            |
   |-------------------+-------------------------+--------------------------------|
   | =internalField=   | Cell values             | Face values and point values   |
   | =patch=           | Face values             | Point values                   |
   | =faceZone=        | Face values             | none                           |
   | =cellZone=        | Cell values             | none                           |
   | =faceSet=         | Face values             | none                           |
   | =cellSet=         | Cell values             | none                           |
   | =set=             | Values on sample points | none                           |
   | =surface=         | Values on the facets    | vertices - not yet implemented |
   | =internalFaField= | Area (=face) values     | Edge values                    |
   | =faPatch=         | Edge values             | Point values                   |

   The following sections describe the basic concepts of the
   expressions.
*** Constants and type building
    This applies to all types of expressions.

    Numeric constants can be written in any form they can be written
    in C++/OpenFOAM. Just a few examples: =42=, =3.1415=, =6.66e2= etc

    The symbol =pi= is $\pi$.

    Vector values can be constructed using the keyword =vector= and
    three scalar values (which can be constants or expressions that
    yield a scalar): for instance =vector(1,2,3)= or
    =vector(1,pos().x,0)=.

    Tensors are constructed with the keyword =tensor= and 9 scalar
    values for the components.

    Symmetric tensors are constructed using the keyword =symmTensor=
    and the 6 components $a_{xx}$, $a_{xy}$, $a_{xz}$, $a_{yy}$,
    $a_{yz}$ and $a_{zz}$.

    Spherical tensors are constructed using =sphericalTensor= and one
    scalar value.

    If no field or variable with the name =I= exists then this gives
    the unit tensor.

    The logical constants =true= and =false= are available
*** Operators
    These operators are implemented for all the parsers (the usual
    precedence-rules apply):
    - =+ - * /= :: Arithmetic operations
    - =&= :: Inner product for vectors and tensors
    - =^= :: Cross product of two vectors
    - =%= :: Modulo operator. The implementation of this operator
             differs from the usual implementations: for an expression
             =a%b= the function is defined in the range
             $\frac{-b}{2}<x<\frac{b}{2}$ as $x$ (not as usual in the
             range $0<x<b$)
    - =&& ||= :: The logical /and/ and /or/ operators
    - =!= :: Logical negation
    - ~< > >= <=~ :: Comparisons
    - ~== !=~ :: Equality and inequality-operators
    - =? := :: /if-then-else/-operator. An expression =a ? b : c=
               means "if the logical expression =a= is =true= the
               value of expression =b= is used. Otherwise the value of
               expression =c="
    In addition there are two unary operators:
    - =-= :: gives the negative of an expression
    - - =*= :: :: the /Hodge dual/ of a tensor expression
**** Component operator =.=
     For the data types with multiple components the single components
     can be accessed as scalar with the operator =.= and the number of
     the component after the expression (for instance =U.x= gives the
     x-component of the field =U=). Table \ref{tab:components} gives
     an overview of the components of the various types
     #+CAPTION: Component names for the data types
     #+LABEL: tab:components
     | Data type          | Components                 |
     |--------------------+----------------------------|
     | Vector             | x y z                      |
     | Tensor             | xx xy xz yx yy yz zx zy zz |
     | Symmetrical tensor | xx xy xz yy yz zz          |
     | Spherical tensor   | ii                         |
     For the tensor types there is also the "component" =T= that
     transposes the tensor (=A.T= gives the transposed tensor for =A=)
*** Mathematical functions available in all parsers
    The mathematical functions described in the /Programmers Guide/
    are implemented in all parsers:
    - mag(x) :: Absolute value $|x|$. Implemented for all
                types. Yields a scalar
    The following functions only work for scalars:
    - pow(x,y) :: Power $x^y$. Only implemented for scalars
    - exp(x) :: Exponential function $e^x$
    - log(x) :: Natural logarithm
    - log10(x) :: Logarithm with the base 10
    - sin, cos, tan :: Usual trigonometric functions
    - asin, acos, atan :: Inverse trigonometric functions
    - sinh, cosh, tanh :: Hyperbolic functions
    - asinh, acosh, atanh :: Inverse hyperbolic functions
    - sqr(x) :: Square $x^2$
    - magSqr(x) :: Square of the magnitude $|x|^2$
    - sqrt(x) :: Square root $\sqrt{x}$
    - erf(x) :: Error function
    - erfc(x) ::Complement error function
    - besselJ0, besselJ1, besselY0, besselY1 :: Bessel-functions
    - lgamma :: Logarithm gamma function
    These functions depend on the sign of a scalar:
    - positive(x) :: $1$ if $0\leq x$. $0$ otherwise
    - negative(x) :: $1$ if $x < 0$. $0$ otherwise
    - sign(x) :: $1$ if $x$ is positive. $-1$ if it is negative
    These functions act on tensors:
    - diag :: returns a vector with the diagonal elements
    - tr :: Trace of the tensor
    - dev :: Deviatoric component
    - symm :: Symmetric component
    - skew :: Skew-symmetric component
    - det :: Determinant
    - cof :: Cofactors
    - inv :: Inverse
    These functions examine the whole fields (in parallel over all
    processors) and return a field which has one value anywhere:
    - max(x) :: maximum of the field (for types with multiple components
             it return the maximum of each component)
    - min(x) :: the minimum
    - maxPosition(x) :: Only defined for scalar expressions. A vector
                     with the position where the maximum value is found
    - minPosition(x) :: Like =maxPosition= but with the minimum
    - sum :: the sum of all the field values
    - average :: the average of the field values
    There are also binary forms:
    - min(x,y) :: Gives back a field that in each "cell" has the
                  minimum of =x= and =y= in that cell
    - max(x,y) :: Same for the maximum
    These functions build on the random numbers available in OpenFOAM:
    - rand :: A random number that is uniformly distributed in the
              range $[0,1)$. It *can* take an integer argument that
              will act as a seed to the random function (if unset the
              seed $0$ is used) but with the number of the current
              timestep added (so that the random distribution is
              different at each time-step but still reproducible)
    - randFixed :: Similar to =rand= but the distribution of the
                   random numbers will stay the same for all
                   time-steps
    - randNormal :: A Gauss-normal distributed random number (seed can
                    be provided). Different at each time-step
    - randNormalFixed :: Like =randNormal= but fixed in time
    These functions are always available. They are not "mathematical"
    but help identify certain entities:
    - id :: the identification number of an element (for instance the
            cell number for an =internalField=). This number is only
            unique on each processor
    - cpu :: The processor number an element on is for a parallel run
*** OpenFOAM-specific functions
    The following functions are not available in all parsers. In the
    description in brackets there will be a shorthand description of
    the parsers in which it will be available (mind: for the subset
    parser this doesn't mean that all drivers actually support this
    function: for instance does the volume function =vol()= not make
    sense for face zones. Calling this function will result in an
    error message). Table \ref{tab:parsershorthand} lists the short
    descriptions.
    #+CAPTION: Shorthand for the parsers
    #+LABEL: tab:parsershorthand
    | Parser            | Shorthand |
    |-------------------+-----------|
    | =internalField=   | F         |
    | =patch=           | P         |
    | =subset=          | S         |
    | =faInternalField= | FF        |
    | =faPatch=         | FP        |
**** Information about the mesh
     These functions give information about the mesh and are used
     without arguments:
     - pos() :: Position of the native structures of the parser (for
                instance cell centers for =internalField=) (F, P, S,
                FF, FP)
     - vol() :: Cell volumes (F, S)
     - area() :: Face area as a scalar (F, P, S, FF)
     - pts() :: Positions of the vertices (F, P, S, FP)
     - fpos() :: Positions of the faces/edges between cells (F, FF)
     - fproj() :: surface field with the projection of the face onto
                  the Cartesian coordinates (F, FF)
     - face() :: Face vectors (F, FF)
     - dist() :: Scalar field that gives the distance to the nearest
                 wall (using =wallDist=) (F, P)
     - nearDist() :: Scalar field that gives the distance to the
                     nearest wall (using =nearWallDist=)(F)
     - rdist() :: A field with the distances from a given vector
                  (shorthand for =mag(pos()-v)=) (F, P, FF)
     - length() :: Edge length (FF, FP)
     - Sf() :: Surface vectors (P, S, FP)
     - Cn() :: Neighbour cell center position (P)
     - Fn() :: Neighbour face center position (FP)
     - delta() :: Cell center to face center vector (P, FP)
     - weights() :: Patch weighting factors (P, FP)
     - normal() :: Normal vectors (P, S, FP)
     These functions are only available in the =internalField=-parser
     and identify cells, faces or points belonging to a certain
     group. Most of them take a name as an argument. The result is a
     boolean field:
     - set(name) :: =True= for all cells in the cell-set =name=
     - zone(name) :: =True= for all cells in the cell-zone =name=
     - fset(name) :: =True= for all faces in the face-set =name=
     - fzone(name) :: =True= for all faces in the face-zone =name=
     - pset(name) :: =True= for all points in the point-set =name=
     - pzone(name) :: =True= for all points in the point-zone =name=
     - onPatch(name) :: =True= for all faces on the patch =name=
     - internalFace() :: =True= for all faces which are *not* on a patch
     This function is only implemented for the Subset-parser:
     - flip() :: For face-zones and face-Sets this gives the
                 orientation of the face. $1$ if the face is oriented
                 in the "right" direction, $-1$ if not. Used to get
                 consistent mass flows etc across these sets/zones
**** Information about time
     Some special functions implemented in all parsers:
     - oldTime(fieldName) :: value of a field at the last time
     - deltaT() :: Scalar field with the current time-step size
     - time() :: Scalar field with the current time
**** Differential operators
     The differential operators are only available in the
     =internalField=-parser. They are available in various forms. In
     the following list an argument like =cellExpr= means "an
     expression of any type defined in a cell", an argument
     =faceScalar= means "only a scalar defined on a face is valid
     here"
     - div(cellExpr) :: Divergence of tensor and vector fields
     - div(faceScalar,cellExpr) :: Divergence with a "face flux"
     - div(faceExpr) :: Divergence of a value defined on faces
     - grad(cellExpr) :: Gradient
     - curl(cellVector) :: Curl of a vector field
     - magSqrGradGrad(cellScalar) :: Whatever the name says
     - snGrad(cellExpr) :: Surface normal defined on the faces
     - laplacian(faceScalar,cellExpr) :: Laplacian with an
          inhomogeneous constant defined on the faces
     - laplacian(cellScalar,cellExpr) :: Laplacian with an
          inhomogeneous constant defined in the cells
     - laplacian(cellExpr) :: Laplacian without a constant
     - ddt(cellFieldName) :: this only works for fields for which the last
                         time-step is stored. Time derivative
     - d2dt2(cellFieldName) :: Second time derivative
     - meshPhi(cellVector) :: Additional flux by the mesh movement
     - meshPhi(cellScalar,cellVector) :: Additional flux
     - flux(faceScalar,cellExpr) :: Flux
     These functions give the explicitly discretized form. For a more
     detailed explanation see the /Programmers Guide/.

     The above functions are also implemented (if appropriate) in the
     =faInternalField=. Additionally these functions are implemented
     there:
     - lnGrad(areaExpr) :: Like =snGrad=
**** Functions that interpolate
     These functions interpolate fields between the native and the
     secondary structure of a parser
     - interpolate(cellExpr) :: Interpolates to the faces (F, FF)
     - interpolateToPoint(cellExpr) :: Interpolates to points (F)
     - interpolateToCell(faceExpr) :: Interpolates to the cells (F)
     - toPoint(faceExpr) :: To the point values (P, S, FP)
     - toFace(pointExpr) :: To the cell values (P, S, FP)
     These functions are not strictly interpolations, but are used to
     calculate a cell value from a face value. They are
     described in detail in the /Programmers Guide/:
     - integrate(faceExpr) :: Integrate over the faces(F, FF)
     - surfSum(faceExpr) :: Sum the values on the faces(F, FF)
     - faceAverage(faceExpr) :: Average of the face values(F, FF)
     - reconstruct(faceScalar) :: Reconstruct a vector field from the
          face fluxes (F)
     These two functions are for quickly generating constant fields:
     - surf(scalar) :: Generate a constant face-field (no
                       interpolation necessary) (F, FF)
     - point(scalar) :: Generate a constant point-field (F)
**** Other fields
     These functions take a field name and return a field from another
     place:
     - mapped(fieldName) :: For a mapped patch get the value of the
          field "on the other side" (P)
     - mappedInternal(fieldName) :: Similar but get the value of the
          internal field "on the other side" (P)
     - internalField(fieldName) :: Get the value of the field on the
          neighbouring internal cells(P, FP)
     - neighbourField(fieldName) :: For a coupled patch get the value
          of the internal field of the coupled patch (P, FP)
     This function is the only "differential operator"" defined on
     patches:
     - snGrad(fieldName) :: Gradient of the field =name= in the
          surface normal direction (P, FP)
*** Variables and fields
*** Plugin functions
** Parameters
* Usable parts
** Utilities
** Boundary conditions
** Function objects
** Function plugins
* Programming
