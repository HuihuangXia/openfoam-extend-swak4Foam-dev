#+TITLE: The /incomplete/ =swak4Foam= reference
#+AUTHOR: Bernhard F.W. Gschaider

* Introduction
  This document gives an overview of the usage of =swak4Foam=. It
  explains the common paramters, expressions and usable parts. It is
  not intended as an introduction to =swak4Foam= (for that have a look
  at
  http://openfoamwiki.net/index.php/File:Swak4Foam_PSU2011_presentation.pdf).

  The structure of the document is
  - the first part gives an overview of the parsers. The parser is the
    part that reads expressions entered by the user and interprets
    them. These parsers are central to =swak4Foam= and this chapter
    explains
    - the expressions
    - common settings and concepts
    - order of evaluations
  - the next part describes the parts of =swak4foam= that are directly
    usable. This means
    - the utilities (including the popular =funkySetFields=)
    - boundary conditions (including =groovyBC=)
    - the collection of function objects
    - and the function plugins that can extend the parsers
  - the last part gives a short descrition on how to use functionality
    of =swak4foam= in your own programs
** Generating a printable version of this document
   This document was written in =org-mode= (http://orgmode.org) an
   outliner mode for the text editor Emacs. This mode offers a number
   of ways to export the contents to nicely formatted =HTML= and
   =PDF=. Please don't try to 'improve' the document in any other
   text-editor as all the indentations etc have special meaning.

   Some of the diagrams require external softaware packages (they are
   automatically called by =org-mode=):
   - Graphviz :: http://www.graphviz.org
   - Ditaa :: http://ditaa.sourceforge.net
   - PlantUML :: http://plantuml.sourceforge.net/
* The parsers (expression grammar)
  The central concept in =swak4Foam= is the /parser/. A parser reads a
  string with an expression, interprets it according to a grammar and
  then evaluates the grammar yielding a result.

  In principle each parser is composed of three elements pictured in
  figure \ref{fig:driverLexerParser}:
  - the =Lexer= which reads the tokens from the string (the lexers are
    generated by =flex= from a special description file)
  - the =GrammarParser= which gets the token from the =lexer= and
    interprets them according to a specified grammer (the grammar
    specification is turned into a program by =bison=)
  - the =Driver= is the part of the parser that is "seen" by the
    calling program. It
    - starts the grammar parser and the lexer
    - assists them in decisions like "is this symbol a variable?"
    - collects the results
    - implements concrete data generation actions (like reading
      fields, getting cell centers, etc)
  In the following texts the term /Parser/ will refer to this complex
  of three entities
  #+CAPTION: Relationship Driver/Lexer/Parser
  #+LABEL: fig:driverLexerParser
#+begin_src plantuml :file parserDriverLexer.png
Driver o-- Lexer
Driver o-- GrammarParser
Lexer .> GrammarParser
#+end_src

#+RESULTS:
[[file:parserDriverLexer.png]]

  Which parser is used depends on the entity the calculation is done
  on and determines the supported functionality (differential
  operators are for instance not available on =patch=). Figure
  \ref{fig:parserRelations} gives an overview of the available
  parser/driver and their relations. Parsers with a =<< grammar >>= in
  the name implement a parser/lexer pair which is used by the drivers
  derived from it. Drivers whose names are in /italics/ are only
  abstract classes.

  As all drivers are derived from /Common/ there is a set of options
  that is available in all drivers/parser.

  #+CAPTION: Inheritance relation of the Parsers
  #+LABEL: fig:parserRelations
#+begin_src plantuml :file parserRelationships.png
package swak4FoamParsers {
Common <|-- Field
Common <|-- Patch
Common <|-- Subset
Subset <|-- SetSubset
SetSubset <|-- CellSet
Subset <|-- CellZone
SetSubset <|-- FaceSet
Subset <|-- FaceZone
Subset <|-- SampledSet
Subset <|-- SampledSurface

class Field << grammar >>
class Patch << grammar >>
abstract class Subset << grammar >>
abstract class SetSubset
abstract class Common
}

package swakFiniteArea {
Common <|-- FaField
Common <|-- FaPatch

class FaField << grammar >>
class FaPatch << grammar >>
}

hide members
hide circle

#+end_src

#+RESULTS:
[[file:parserRelationships.png]]

  Usually the parser used is determined by the using entity (for
  instance =patch= is used by =groovyBC=) but sometimes (for instance
  the =swakExpression=-function object) the used parser can by
  selected by name. These names and a description of the entity the
  parser works on are given in table \ref{tab:selectionNames}.

  #+CAPTION: Selection names for the parsers
  #+LABEL: tab:selectionNames
  | name              | Description                                     |
  |-------------------+-------------------------------------------------|
  | =internalField=   | Calculation on the internal values of a field   |
  | =patch=           | Calculation on a boundary patch                 |
  | =faceZone=        | On a =faceZone= of the mesh                     |
  | =faceSet=         | On a =faceSet=                                  |
  | =cellZone=        | Calculation on a =cellZone=                     |
  | =cellSet=         | Set of cells                                    |
  | =set=             | Calculation on a =sampledSet=                   |
  | =surface=         | Calculation on a =sampledSurface=               |
  | =internalFaField= | Internal values of a FAM-field (=1.6-ext= only) |
  | =faPatch=         | Boundary patch of a FAM-field (=1.6-ext= only)  |

  In principle new parsers for different entities can be implemented
  and selected at run-time (as for instance are the /FAM/-parsers
  which are located in a separate library that has to be loaded at
  run-time)
** Expressions
   The basic syntax of the expressions is modelled after the syntax of
   expressions in OpenFOAM-programs. This means:
   - the syntax is C++
     - the usual precedence rules apply
   - if possible the same operators and function names as in OpenFOAM
     are used
   The type of result of an exprerssion does not have to be
   declared. swak4Foam determines it from the expression. In certain
   cases the calling entity (BC, functionObject etc) expects a certain
   type and will complain *after* the evaluation has finished.

   Available types are
   - scalar :: ordinary floating point expressions
   - vector :: a three component vector (usually describing a position
               in space)
   - tensor :: a tensor with $3 \times 3$ components
   - symmTensor :: a $3 \times 3$ symmetric tensor (for the components
                   $a_{ij}=a_{ji}$)
   - sphericalTensor :: Spherical tensor
   - boolean :: results of logical operations (can only be =true= or
                =false=). Certain parsers implement them with scalars
                being $0$ or $1$

   If the type of subexpressions for a certain operator/function is
   incompatible (for instance when trying to add a vector to a scalar)
   the parser will issue an error message during the evaluation.

   Most parsers have two kinds of structures where calculations are
   performed:
   1. the "native" structure of that parser. For instance for the
      =internalField=-parser this would be the values in the cells
   2. the "secondary" structure of the parser. For the =internalField=
      this would be the value on the faces (=internalField= is special
      as it also has another /secondary/ structure: the values on the
      vertexes)
   swak4Foam does *not* automatically convert values between these
   structures (as it usually involves an interpolation) but specific
   functions has to be used. The parser will complain if
   subexpressions of different structures are combined. This usually
   leads to confusion with constants which are defined on the /native/
   structure and have to be converted explicitly to the secondary
   structure if necessary (for instance =toPoint(1)= to use the
   constant =1= on the vertexes of a patch). Table
   \ref{tab:structures} gives an overview of the structures.

   #+CAPTION: Structures for the different parsers
   #+LABEL: tab:structures
   | Parser            | /native/ structure      | secondary structure            |
   |-------------------+-------------------------+--------------------------------|
   | =internalField=   | Cell values             | Face values and point values   |
   | =patch=           | Face values             | Point values                   |
   | =faceZone=        | Face values             | none                           |
   | =cellZone=        | Cell values             | none                           |
   | =faceSet=         | Face values             | none                           |
   | =cellSet=         | Cell values             | none                           |
   | =set=             | Values on sample points | none                           |
   | =surface=         | Values on the facets    | vertices - not yet implemented |
   | =internalFaField= | Area (=face) values     | Edge values                    |
   | =faPatch=         | Edge values             | Point values                   |

   The following sections describe the basic concepts of the
   expressions.
*** Constants and type building
    This applies to all types of expressions.

    Numeric constants can be written in any form they can be written
    in C++/OpenFOAM. Just a few examples: =42=, =3.1415=, =6.66e2= etc

    The symbol =pi= is $\pi$.

    Vector values can be constructed using the keyword =vector= and
    three scalar values (which can be constants or expressions that
    yield a scalar): for instance =vector(1,2,3)= or
    =vector(1,pos().x,0)=.

    Tensors are constructed with the keyword =tensor= and 9 scalar
    values for the components.

    Symmetric tensors are constructed using the keyword =symmTensor=
    and the 6 components $a_{xx}$, $a_{xy}$, $a_{xz}$, $a_{yy}$,
    $a_{yz}$ and $a_{zz}$.

    Spherical tensors are constructed using =sphericalTensor= and one
    scalar value.

    If no field or variable with the name =I= exists then this gives
    the unit tensor.

    The logical constants =true= and =false= are available
*** Operators
    These operators are implemented for all the parsers (the usual
    precedence-rules apply):
    - =+ - * /= :: Arithmetic operations
    - =&= :: Inner product for vectors and tensors
    - =^= :: Cross product of two vectors
    - =%= :: Modulo operator. The implementation of this operator
             differs from the usual implementations: for an expression
             =a%b= the function is defined in the range
             $\frac{-b}{2}<x<\frac{b}{2}$ as $x$ (not as usual in the
             range $0<x<b$)
    - =&& ||= :: The logical /and/ and /or/ operators
    - =!= :: Logical negation
    - ~< > >= <=~ :: Comparisons
    - ~== !=~ :: Equality and inequality-operators
    - =? := :: /if-then-else/-operator. An expression =a ? b : c=
               means "if the logical expression =a= is =true= the
               value of expression =b= is used. Otherwise the value of
               expression =c="
    In addition there are two unary operators:
    - =-= :: gives the negative of an expression
    - - =*= :: :: the /Hodge dual/ of a tensor expression
**** Component operator =.=
     For the data types with multiple components the single components
     can be accessed as scalar with the operator =.= and the number of
     the component after the expression (for instance =U.x= gives the
     x-component of the field =U=). Table \ref{tab:components} gives
     an overview of the components of the various types
     #+CAPTION: Component names for the data types
     #+LABEL: tab:components
     | Data type          | Components                 |
     |--------------------+----------------------------|
     | Vector             | x y z                      |
     | Tensor             | xx xy xz yx yy yz zx zy zz |
     | Symmetrical tensor | xx xy xz yy yz zz          |
     | Spherical tensor   | ii                         |
     For the tensor types there is also the "component" =T= that
     transposes the tensor (=A.T= gives the transposed tensor for =A=)
*** Mathematical functions
    The mathematical functions described in the /Programmers Guide/
    are implemented in all parsers:
    - mag(x) :: Absolute value $|x|$. Implemented for all
                types. Yields a scalar
    The following functions only work for scalars:
    - pow(x,y) :: Power $x^y$. Only implemented for scalars
    - exp(x) :: Exponential function $e^x$
    - log(x) :: Natural logarithm
    - log10(x) :: Logarithm with the base 10
    - sin, cos, tan :: Usual trigonometric functions
    - asin, acos, atan :: Inverse trigonometric functions
    - sinh, cosh, tanh :: Hyperbolic functions
    - asinh, acosh, atanh :: Inverse hyperbolic functions
    - sqr(x) :: Square $x^2$
    - magSqr(x) :: Square of the magnitude $|x|^2$
    - sqrt(x) :: Square root $\sqrt{x}$
    - erf(x) :: Error function
    - erfc(x) ::Complement error function
    - besselJ0, besselJ1, besselY0, besselY1 :: Bessel-functions
    - lgamma :: Logarithm gamma function
    These functions depend on the sign of a scalar:
    - pos(x) :: $1$ if $0\leq x$. $0$ otherwise
    - neg(x) :: $1$ if $x < 0$. $0$ otherwise
    - sign(x) :: $1$ if $x$ is positive. $-1$ if it is negative
    These functions act on tensors:
    - diag :: returns a vector with the diagonal elements
    - tr :: Trace of the tensor
    - dev :: Deviatoric component
    - symm :: Symmetric component
    - skew :: Skew-symmetric component
    - det :: Determinant
    - cof :: Cofactors
    - inv :: Inverse
*** OpenFOAM-specific functions
*** Variables and fields
*** Plugin functions
** Parameters
* Usable parts
** Utilities
** Boundary conditions
** Function objects
** Function plugins
* Programming
